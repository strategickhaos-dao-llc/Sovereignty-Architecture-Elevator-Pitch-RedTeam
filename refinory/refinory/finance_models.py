"""
Financial Models for Hybrid Refinery System
Strategickhaos Sovereign Income Architecture

This module defines the core data models for:
- Dividend Engine (passive income layer)
- Refinery Overlay (signals and filtering)
- RANCO/PID Tactical Sleeve (structured mechanical trading)
- Portfolio and Risk Management
"""

from dataclasses import dataclass, field
from datetime import datetime, timezone
from decimal import Decimal
from enum import Enum
from typing import Dict, List, Optional, Any
import uuid


# =============================================================================
# Core Enums
# =============================================================================

class AssetClass(Enum):
    """Asset classification for portfolio management"""
    EQUITY = "equity"
    REIT = "reit"
    UTILITY = "utility"
    MLP = "mlp"
    ETF = "etf"
    PREFERRED = "preferred"
    BOND = "bond"


class PositionType(Enum):
    """Position classification within the portfolio"""
    CORE_DIVIDEND = "core_dividend"      # Long-term dividend holdings
    TACTICAL_RANCO = "tactical_ranco"    # RANCO/PID tactical positions
    CASH = "cash"                        # Cash buffer


class SignalType(Enum):
    """Types of signals generated by the refinery"""
    SAFE_ADD = "safe_add"                # Dividend stock at attractive entry
    AVOID = "avoid"                       # Stock to avoid due to risk factors
    RANCO_ENTRY = "ranco_entry"          # RANCO entry signal
    RANCO_EXIT = "ranco_exit"            # RANCO exit signal
    REBALANCE = "rebalance"              # Portfolio rebalancing needed
    RISK_ALERT = "risk_alert"            # Risk threshold breached


class RiskLevel(Enum):
    """Risk classification levels"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AccountType(Enum):
    """Account types for flow management"""
    CORE = "core"                        # Core dividend account
    TACTICAL = "tactical"                # RANCO tactical account
    TREASURY = "treasury"                # Cash buffer treasury
    SWARMGATE = "swarmgate"              # SwarmGate allocation (7%)


# =============================================================================
# Guardrails Configuration (Non-negotiable rules)
# =============================================================================

@dataclass
class Guardrails:
    """
    Non-negotiable safety rules for the entire system.
    These limits are hard-coded and should NEVER be bypassed.
    """
    # Position limits
    max_single_position_pct: Decimal = Decimal("0.05")      # 5% max per position
    max_sector_allocation_pct: Decimal = Decimal("0.20")    # 20% max per sector
    
    # Risk controls
    hard_stop_loss_pct: Decimal = Decimal("0.12")           # 12% stop loss
    soft_stop_loss_pct: Decimal = Decimal("0.08")           # 8% trailing stop
    
    # Cash management
    min_cash_buffer_pct: Decimal = Decimal("0.10")          # 10% minimum cash
    max_cash_buffer_pct: Decimal = Decimal("0.20")          # 20% maximum cash
    
    # Leverage (FORBIDDEN)
    allow_leverage: bool = False
    allow_options: bool = False
    allow_margin: bool = False
    
    # Drawdown limits
    max_portfolio_drawdown_pct: Decimal = Decimal("0.12")   # 12% max drawdown
    tactical_risk_cut_threshold: Decimal = Decimal("0.50")  # Cut tactical risk by 50% at threshold
    
    def validate(self) -> List[str]:
        """Validate guardrails are reasonable"""
        errors = []
        if self.allow_leverage or self.allow_options or self.allow_margin:
            errors.append("Leverage, options, and margin are FORBIDDEN")
        if self.max_single_position_pct > Decimal("0.10"):
            errors.append("Single position limit too high (max 10%)")
        if self.max_sector_allocation_pct > Decimal("0.30"):
            errors.append("Sector allocation limit too high (max 30%)")
        return errors


# =============================================================================
# Dividend Engine Models
# =============================================================================

@dataclass
class DividendScreenCriteria:
    """
    Screening criteria for dividend stocks.
    Safe, boring, passive income selection.
    """
    # Payout safety
    max_payout_ratio: Decimal = Decimal("0.70")             # < 70% (REITs: 80%)
    max_payout_ratio_reit: Decimal = Decimal("0.80")        # FFO payout for REITs
    
    # Growth requirements
    min_dividend_growth_5yr_cagr: Decimal = Decimal("0.03") # > 3% CAGR
    
    # Financial health
    min_interest_coverage: Decimal = Decimal("4.0")         # > 4x coverage
    max_net_debt_ebitda: Decimal = Decimal("3.0")           # < 3x (REITs: 6x)
    max_net_debt_ebitda_reit: Decimal = Decimal("6.0")
    
    # Quality metrics
    min_roic_premium_over_wacc: Decimal = Decimal("0.02")   # ROIC > WACC + 2%
    
    # Universe filters
    require_dividend_aristocrat: bool = False                # Optional aristocrat status
    require_dividend_achiever: bool = False                  # Optional achiever status
    
    # Liquidity requirements
    min_avg_daily_volume_usd: Decimal = Decimal("1000000")  # $1M ADV minimum


@dataclass
class DividendStock:
    """Individual dividend stock data"""
    ticker: str
    name: str
    asset_class: AssetClass
    sector: str
    
    # Current metrics
    current_price: Decimal
    dividend_yield: Decimal
    annual_dividend: Decimal
    payout_ratio: Decimal
    
    # Historical metrics
    dividend_growth_5yr_cagr: Decimal
    dividend_streak_years: int
    
    # Financial health
    interest_coverage: Decimal
    net_debt_ebitda: Decimal
    roic: Decimal
    wacc: Decimal
    
    # Valuation
    pe_ratio: Optional[Decimal] = None
    price_to_book: Optional[Decimal] = None
    
    # Screening results
    passes_screen: bool = False
    screen_failures: List[str] = field(default_factory=list)
    
    # Timestamps
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class DividendEngineConfig:
    """Configuration for the Dividend Engine layer"""
    # Portfolio construction
    target_positions: int = 25                               # 20-30 names
    min_positions: int = 20
    max_positions: int = 30
    
    # Weighting strategy
    weighting_method: str = "risk_weight"                    # equal_weight | risk_weight
    max_weight_per_stock: Decimal = Decimal("0.05")
    
    # Reinvestment rules
    reinvest_dividends_pct: Decimal = Decimal("0.70")        # 70% reinvest
    treasury_allocation_pct: Decimal = Decimal("0.23")       # 23% to treasury
    swarmgate_allocation_pct: Decimal = Decimal("0.07")      # 7% to SwarmGate
    
    # Rebalancing
    rebalance_frequency: str = "quarterly"                   # quarterly | monthly
    rebalance_threshold_pct: Decimal = Decimal("0.05")       # 5% drift triggers rebalance
    
    # Screening criteria
    screen_criteria: DividendScreenCriteria = field(default_factory=DividendScreenCriteria)


# =============================================================================
# Refinery Overlay Models (Signals, not gambling)
# =============================================================================

@dataclass
class TechnicalIndicators:
    """Technical indicators for signal generation"""
    # Price and volume
    current_price: Decimal
    avg_daily_volume: Decimal
    
    # Moving averages
    ma_20: Decimal
    ma_50: Decimal
    ma_200: Decimal
    
    # Volatility
    atr_14: Decimal                                          # Average True Range (14-period)
    atr_pct: Decimal                                         # ATR as percentage of price
    
    # Momentum
    rsi_14: Decimal                                          # RSI (14-period)
    
    # Optional fields with defaults (must come after required fields)
    atr_6mo_median: Optional[Decimal] = None
    
    # Trend indicators
    higher_low_formed: bool = False
    ma_alignment_bullish: bool = False                       # 20 > 50 > 200
    
    # Timestamp
    as_of: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class FundamentalData:
    """Fundamental data for overlay analysis"""
    ticker: str
    
    # Earnings
    earnings_date: Optional[datetime] = None
    days_to_earnings: Optional[int] = None
    earnings_revision_trend: str = "neutral"                 # up | neutral | down
    
    # Dividend health
    payout_ratio: Decimal = Decimal("0")
    payout_stretch_warning: bool = False
    
    # Quality flags
    fundamentals_intact: bool = True
    avoid_reasons: List[str] = field(default_factory=list)


@dataclass
class RefinerySignal:
    """Signal generated by the Refinery Overlay"""
    signal_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    ticker: str = ""
    signal_type: SignalType = SignalType.SAFE_ADD
    
    # Signal details
    confidence: Decimal = Decimal("0.5")                     # 0-1 confidence score
    priority: str = "normal"                                 # low | normal | high
    
    # Entry/Exit parameters (for actionable signals)
    suggested_entry: Optional[Decimal] = None
    suggested_stop: Optional[Decimal] = None
    suggested_target: Optional[Decimal] = None
    suggested_size_pct: Optional[Decimal] = None
    
    # Context
    reasoning: List[str] = field(default_factory=list)
    technical_data: Optional[TechnicalIndicators] = None
    fundamental_data: Optional[FundamentalData] = None
    
    # Timestamps
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None
    
    # Status
    acted_upon: bool = False
    action_result: Optional[str] = None


@dataclass  
class RefineryOverlayConfig:
    """Configuration for the Refinery Overlay layer"""
    # Data sources
    data_sources: List[str] = field(default_factory=lambda: [
        "price_volume", "atr", "moving_averages", "rsi", "fundamentals"
    ])
    
    # Exclusion rules
    exclude_earnings_window_days: int = 5                    # Â±5 days from earnings
    min_adv_for_signals: Decimal = Decimal("1000000")        # $1M ADV minimum
    
    # Safe add criteria (dividend dips)
    safe_add_near_ma200_pct: Decimal = Decimal("0.05")       # Within 5% of 200MA
    safe_add_atr_downtrend: bool = True                      # ATR in downtrend
    
    # Avoid criteria
    avoid_payout_stretch_threshold: Decimal = Decimal("0.80")
    avoid_earnings_revision_down: bool = True
    
    # Output configuration
    generate_watchlists: bool = True
    watchlist_output_format: str = "csv"                     # csv | json


# =============================================================================
# RANCO/PID Tactical Models
# =============================================================================

@dataclass
class RANCOEntryRules:
    """
    RANCO/PID Entry Rules - Structured, mechanical, zero-emotion.
    This is ENGINEERING, not speculation.
    """
    # Volatility compression (ATR% below 6-month median)
    require_volatility_compression: bool = True
    atr_pct_below_median: bool = True
    
    # Trend alignment (20 > 50 > 200 moving averages)
    require_ma_alignment: bool = True
    
    # RSI range (not overbought, not oversold)
    rsi_min: Decimal = Decimal("45")
    rsi_max: Decimal = Decimal("65")
    
    # Price pattern
    require_higher_low: bool = True
    
    # Timing
    trading_frequency: str = "weekly"                        # weekly only, no intraday


@dataclass
class RANCOExitRules:
    """RANCO/PID Exit Rules - Strict, mechanical"""
    # Initial stop
    initial_stop_atr_multiplier: Decimal = Decimal("1.5")    # 1.5x ATR below entry
    
    # Trailing stop
    trailing_stop_atr_multiplier: Decimal = Decimal("2.0")   # 2x ATR trail
    
    # Profit taking
    rsi_overbought_threshold: Decimal = Decimal("75")
    exit_on_first_lower_high_after_overbought: bool = True


@dataclass
class RANCOSizingRules:
    """Position sizing for RANCO tactical trades"""
    # Kelly-based sizing
    use_kelly_fraction: bool = True
    kelly_divisor: int = 5                                   # Kelly / 5
    
    # Fixed risk alternative
    max_risk_per_trade_pct: Decimal = Decimal("0.01")        # 0.5-1% of equity
    min_risk_per_trade_pct: Decimal = Decimal("0.005")
    
    # Position limits
    max_tactical_allocation_pct: Decimal = Decimal("0.20")   # 10-20% of portfolio


@dataclass
class RANCOCandidate:
    """RANCO trading candidate"""
    ticker: str
    
    # Entry criteria status
    volatility_compressed: bool = False
    ma_aligned: bool = False
    rsi_in_range: bool = False
    higher_low_formed: bool = False
    
    # Calculated parameters
    entry_price: Optional[Decimal] = None
    stop_price: Optional[Decimal] = None
    position_size_pct: Optional[Decimal] = None
    risk_reward_ratio: Optional[Decimal] = None
    
    # All criteria met
    is_valid_candidate: bool = False
    
    # Technical data
    technical_data: Optional[TechnicalIndicators] = None
    
    # Timestamps
    identified_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class RANCOTacticalConfig:
    """Configuration for RANCO/PID Tactical Sleeve"""
    # Allocation
    max_tactical_allocation_pct: Decimal = Decimal("0.20")   # 10-20% of capital
    min_tactical_allocation_pct: Decimal = Decimal("0.10")
    
    # Rules
    entry_rules: RANCOEntryRules = field(default_factory=RANCOEntryRules)
    exit_rules: RANCOExitRules = field(default_factory=RANCOExitRules)
    sizing_rules: RANCOSizingRules = field(default_factory=RANCOSizingRules)
    
    # Execution
    trading_frequency: str = "weekly"                        # Weekly only
    max_open_positions: int = 5
    
    # Automation
    auto_place_orders: bool = False                          # Manual confirmation required
    staged_entry_tranches: int = 3                           # Enter in 3 tranches


# =============================================================================
# Portfolio and Position Models
# =============================================================================

@dataclass
class Position:
    """Individual portfolio position"""
    position_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    ticker: str = ""
    name: str = ""
    
    # Position details
    position_type: PositionType = PositionType.CORE_DIVIDEND
    account_type: AccountType = AccountType.CORE
    
    # Quantity and pricing
    shares: Decimal = Decimal("0")
    avg_cost_basis: Decimal = Decimal("0")
    current_price: Decimal = Decimal("0")
    
    # P&L
    unrealized_pnl: Decimal = Decimal("0")
    unrealized_pnl_pct: Decimal = Decimal("0")
    realized_pnl: Decimal = Decimal("0")
    
    # Dividend tracking (for core positions)
    annual_dividend_income: Decimal = Decimal("0")
    dividend_yield_on_cost: Decimal = Decimal("0")
    
    # Risk management
    stop_loss_price: Optional[Decimal] = None
    trailing_stop_pct: Optional[Decimal] = None
    
    # Timestamps
    opened_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    @property
    def market_value(self) -> Decimal:
        """Calculate current market value"""
        return self.shares * self.current_price
    
    @property
    def cost_basis_total(self) -> Decimal:
        """Calculate total cost basis"""
        return self.shares * self.avg_cost_basis


@dataclass
class CashFlow:
    """Cash flow tracking for account management"""
    flow_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    # Source and destination
    source_account: AccountType = AccountType.CORE
    destination_account: AccountType = AccountType.TREASURY
    
    # Amount and description
    amount: Decimal = Decimal("0")
    description: str = ""
    flow_type: str = "dividend"                              # dividend | rebalance | deposit | withdrawal
    
    # Timestamps
    occurred_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class Portfolio:
    """Complete portfolio state"""
    portfolio_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = "Sovereignty Portfolio"
    
    # Positions
    positions: Dict[str, Position] = field(default_factory=dict)
    
    # Account balances
    core_account_value: Decimal = Decimal("0")
    tactical_account_value: Decimal = Decimal("0")
    treasury_balance: Decimal = Decimal("0")
    swarmgate_balance: Decimal = Decimal("0")
    
    # Total portfolio metrics
    total_value: Decimal = Decimal("0")
    total_unrealized_pnl: Decimal = Decimal("0")
    total_realized_pnl: Decimal = Decimal("0")
    
    # Dividend metrics
    annual_dividend_income: Decimal = Decimal("0")
    portfolio_yield: Decimal = Decimal("0")
    
    # Risk metrics
    current_drawdown_pct: Decimal = Decimal("0")
    max_drawdown_pct: Decimal = Decimal("0")
    cash_allocation_pct: Decimal = Decimal("0")
    
    # Allocation breakdown
    sector_allocations: Dict[str, Decimal] = field(default_factory=dict)
    asset_class_allocations: Dict[str, Decimal] = field(default_factory=dict)
    
    # Timestamps
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    last_updated: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Configuration
    guardrails: Guardrails = field(default_factory=Guardrails)
    dividend_config: DividendEngineConfig = field(default_factory=DividendEngineConfig)
    overlay_config: RefineryOverlayConfig = field(default_factory=RefineryOverlayConfig)
    tactical_config: RANCOTacticalConfig = field(default_factory=RANCOTacticalConfig)


# =============================================================================
# Watchlist and Automation Models
# =============================================================================

@dataclass
class Watchlist:
    """Generated watchlist from the Refinery"""
    watchlist_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    watchlist_type: str = ""                                 # dividends_core | safe_add | ranco_candidates
    
    # Tickers
    tickers: List[str] = field(default_factory=list)
    
    # Details
    entries: List[Dict[str, Any]] = field(default_factory=list)
    
    # Timestamps
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    expires_at: Optional[datetime] = None


@dataclass
class AutomationRule:
    """Automation rule for the refinery"""
    rule_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    name: str = ""
    description: str = ""
    
    # Trigger conditions
    trigger_type: str = ""                                   # signal | schedule | threshold
    trigger_conditions: Dict[str, Any] = field(default_factory=dict)
    
    # Actions
    action_type: str = ""                                    # alert | buy | sell | rebalance
    action_parameters: Dict[str, Any] = field(default_factory=dict)
    
    # Constraints
    requires_confirmation: bool = True                       # Human confirmation required
    max_executions_per_day: int = 3
    
    # Status
    enabled: bool = True
    last_triggered: Optional[datetime] = None
    execution_count: int = 0


@dataclass
class RiskAlert:
    """Risk management alert"""
    alert_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    alert_type: str = ""                                     # drawdown | concentration | liquidity
    risk_level: RiskLevel = RiskLevel.MEDIUM
    
    # Details
    ticker: Optional[str] = None
    message: str = ""
    current_value: Decimal = Decimal("0")
    threshold_value: Decimal = Decimal("0")
    
    # Recommendations
    recommended_action: str = ""
    
    # Status
    acknowledged: bool = False
    resolved: bool = False
    
    # Timestamps
    triggered_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    acknowledged_at: Optional[datetime] = None
    resolved_at: Optional[datetime] = None


# =============================================================================
# Validation and Backtest Models
# =============================================================================

@dataclass
class BacktestResult:
    """Results from backtesting rules"""
    backtest_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    strategy_name: str = ""
    
    # Parameters
    start_date: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    end_date: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    initial_capital: Decimal = Decimal("100000")
    
    # Results
    final_value: Decimal = Decimal("0")
    total_return_pct: Decimal = Decimal("0")
    cagr: Decimal = Decimal("0")
    
    # Risk metrics
    max_drawdown_pct: Decimal = Decimal("0")
    sharpe_ratio: Decimal = Decimal("0")
    sortino_ratio: Decimal = Decimal("0")
    
    # Trade statistics
    total_trades: int = 0
    winning_trades: int = 0
    losing_trades: int = 0
    win_rate: Decimal = Decimal("0")
    avg_win: Decimal = Decimal("0")
    avg_loss: Decimal = Decimal("0")
    profit_factor: Decimal = Decimal("0")
    
    # Dividend statistics (for dividend strategies)
    total_dividends_received: Decimal = Decimal("0")
    avg_yield: Decimal = Decimal("0")
    dividend_growth: Decimal = Decimal("0")
    
    # Generated at
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class MonteCarloResult:
    """Monte Carlo simulation results for risk scenarios"""
    simulation_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    
    # Parameters
    num_simulations: int = 1000
    time_horizon_years: int = 10
    
    # Scenario: Dividend cuts
    dividend_cut_probability: Decimal = Decimal("0.10")
    avg_cut_magnitude: Decimal = Decimal("0.25")
    
    # Results
    median_final_value: Decimal = Decimal("0")
    p5_final_value: Decimal = Decimal("0")                   # 5th percentile (bad case)
    p95_final_value: Decimal = Decimal("0")                  # 95th percentile (good case)
    
    # Risk metrics
    probability_of_ruin: Decimal = Decimal("0")
    probability_of_goal: Decimal = Decimal("0")
    max_drawdown_distribution: Dict[str, Decimal] = field(default_factory=dict)
    
    # Generated at
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


# =============================================================================
# Weekly Reporting Models
# =============================================================================

@dataclass
class WeeklyReport:
    """Weekly P&L and status report"""
    report_id: str = field(default_factory=lambda: str(uuid.uuid4()))
    week_ending: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
    
    # Portfolio summary
    portfolio_value: Decimal = Decimal("0")
    weekly_pnl: Decimal = Decimal("0")
    weekly_pnl_pct: Decimal = Decimal("0")
    
    # Dividend summary
    dividends_received: Decimal = Decimal("0")
    dividend_run_rate: Decimal = Decimal("0")                # Annual projected
    
    # Risk summary
    current_drawdown_pct: Decimal = Decimal("0")
    risk_score: str = "green"                                # green | yellow | red
    
    # Activity summary
    trades_executed: int = 0
    signals_generated: int = 0
    alerts_triggered: int = 0
    
    # Flow summary
    swarmgate_flow: Decimal = Decimal("0")                   # 7% allocation
    
    # Heatmap data
    sector_performance: Dict[str, Decimal] = field(default_factory=dict)
    position_heatmap: Dict[str, Decimal] = field(default_factory=dict)
    
    # Generated at
    generated_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))
